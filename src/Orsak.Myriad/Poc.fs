namespace Orsak.Myriad.Poc


open Orsak
open Orsak.Myriad.Gen

open System.Threading
open Microsoft.Extensions.Caching.Memory

type ITest =
    inherit IProvide<CancellationTokenSource>
    inherit IProvide<IMemoryCache>
    inherit IProvide<IRandomGenerator>


//Generated by myriad

open Orsak.Myriad.Writer
open System.Runtime.InteropServices


type Runner1 = {
    CancellationTokenSource: CancellationTokenSource
    MemoryCache: IMemoryCache
} with

    interface IProvide<CancellationTokenSource> with
        member this.Effect = this.CancellationTokenSource

    interface IProvide<IMemoryCache> with
        member this.Effect = this.MemoryCache

type Runner2 = {
    MemoryCache: IMemoryCache
    RandomGenerator: IRandomGenerator
} with

    interface IProvide<IMemoryCache> with
        member this.Effect = this.MemoryCache

    interface IProvide<IRandomGenerator> with
        member this.Effect = this.RandomGenerator

type Runner3 = {
    CancellationTokenSource: CancellationTokenSource
    MemoryCache: IMemoryCache
    RandomGenerator: IRandomGenerator
} with

    interface IProvide<CancellationTokenSource> with
        member this.Effect = this.CancellationTokenSource

    interface IProvide<IMemoryCache> with
        member this.Effect = this.MemoryCache

    interface IProvide<IRandomGenerator> with
        member this.Effect = this.RandomGenerator

type CancellationTokenSourceExtractor =
    //2 + 3 + 4 + 5 + 6 upto 15?
    static member Extract(_: CancellationTokenSourceExtractor, e: EffectContext<CancellationTokenSource, 'b>) = e.A
    static member Extract(_: CancellationTokenSourceExtractor, e: EffectContext<'a, CancellationTokenSource>) = e.B
    //thrice
    static member Extract(_: CancellationTokenSourceExtractor, e: EffectContext<CancellationTokenSource, 'b, 'c>) = e.A
    static member Extract(_: CancellationTokenSourceExtractor, e: EffectContext<'a, CancellationTokenSource, 'c>) = e.B
    static member Extract(_: CancellationTokenSourceExtractor, e: EffectContext<'a, 'b, CancellationTokenSource>) = e.C
//only generate the clusters, for which the effect is part of a runner of that size.
//so if the effect is not a part of a runner with 4 effects, we don't need to generate an extractor of size 4.

type MemoryCacheExtractor =
    //twice
    static member Extract(_: MemoryCacheExtractor, e: EffectContext<IMemoryCache, 'b>) = e.A
    static member Extract(_: MemoryCacheExtractor, e: EffectContext<'a, IMemoryCache>) = e.B
    //thrice
    static member Extract(_: MemoryCacheExtractor, e: EffectContext<IMemoryCache, 'b, 'c>) = e.A
    static member Extract(_: MemoryCacheExtractor, e: EffectContext<'a, IMemoryCache, 'c>) = e.B
    static member Extract(_: MemoryCacheExtractor, e: EffectContext<'a, 'b, IMemoryCache>) = e.C

//done
type RandomGeneratorExtractor =
    //twice
    static member Extract(_: RandomGeneratorExtractor, e: EffectContext<IRandomGenerator, 'b>) = e.A
    static member Extract(_: RandomGeneratorExtractor, e: EffectContext<'a, IRandomGenerator>) = e.B
    //thrice
    static member Extract(_: RandomGeneratorExtractor, e: EffectContext<IRandomGenerator, 'b, 'c>) = e.A
    static member Extract(_: RandomGeneratorExtractor, e: EffectContext<'a, IRandomGenerator, 'c>) = e.B
    static member Extract(_: RandomGeneratorExtractor, e: EffectContext<'a, 'b, IRandomGenerator>) = e.C

[<AutoOpen>]
module Extractors =
    //one per registered effect
    let inline (|ExtractRandomGenerator|) a : IRandomGenerator =
        extract Unchecked.defaultof<RandomGeneratorExtractor> a

    let inline (|ExtractMemoryCache|) a : IMemoryCache =
        extract Unchecked.defaultof<MemoryCacheExtractor> a

    let inline (|ExtractCancellationTokenSource|) a : CancellationTokenSource =
        extract Unchecked.defaultof<CancellationTokenSourceExtractor> a

//done?
type EffectRunnerBuilder() =
    member _.Yield(_: unit) = EffectContext()
    member inline _.Run(a: EffectContext<'a>) = Runner.createFrom a.A

    [<CustomOperation("fromEffect")>]
    member inline _.FromEffect(x: GenContext<_, _, _>, p: CancellationTokenSource) = x.Create(p)

    [<CustomOperation("fromEffect")>]
    member inline _.FromEffect(x: GenContext<_, _, _>, p: IMemoryCache) = x.Create(p)

    [<CustomOperation("fromEffect")>]
    member inline _.FromEffect(x: GenContext<_, _, _>, p: IRandomGenerator) = x.Create(p)

    member inline _.Run(a, [<Optional>]_a: byte, [<Optional>]_b: sbyte) =
        match a with
        | ExtractCancellationTokenSource(a) & ExtractMemoryCache(b) -> {
            CancellationTokenSource = a
            MemoryCache = b
        }

    member inline _.Run(a, [<Optional>]_a: sbyte, [<Optional>]_b: int16) =
        match a with
        | ExtractMemoryCache(a) & ExtractRandomGenerator(b) -> {
            MemoryCache = a
            RandomGenerator = b
        }

    //one per desired runner.
    member inline _.Run(a) =
        match a with
        | ExtractRandomGenerator(a) & ExtractMemoryCache(c) & ExtractCancellationTokenSource(t) -> {
            RandomGenerator = a
            MemoryCache = c
            CancellationTokenSource = t
          }

module Silly =
    let mkRunner = EffectRunnerBuilder()


    let asd (p: CancellationTokenSource, m: IMemoryCache, r: IRandomGenerator) = mkRunner {
        fromEffect m
        fromEffect r
        fromEffect p

    }
