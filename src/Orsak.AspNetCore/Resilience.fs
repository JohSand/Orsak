namespace rec Orsak.AspNetCore

open System
open System.Threading
open System.Threading.Tasks
open Polly
open Polly.Retry
open Orsak
open Microsoft.FSharp.Linq

type Nothing = private Nothing of Nothing

[<AutoOpen>]
module NothingPatterns =
    let (|Safe|) (r: Result<'a, Nothing>) =
        match r with
        | Ok a -> a
        | Error(Nothing _) ->
            Throwhelpers.argumentException "Nothing should be impossible to construct."
            Unchecked.defaultof<_>

type RetryStrategy(_p: TimeProvider, t: CancellationToken) =
    let d = RetryStrategyOptions()
    let mutable attempt = -1
    let mutable prevDelay = 0.

    new(ct) = RetryStrategy(TimeProvider.System, ct)

    member private _.Delay() =
        if attempt = -1 then
            attempt <- attempt + 1
            Task.CompletedTask
        else
            let (delay: TimeSpan) = Resilience.getRetryDelay attempt &prevDelay d
            attempt <- attempt + 1
#if NET8_0_OR_GREATER
            Task.Delay(delay, _p, t)
#else
            Task.Delay(delay, t)
#endif
    member this.Delay(e: Effect<_, _, _>) = eff {
        do! this.Delay()
        return! e
    }

module Resilience =
    [<Literal>]
    let ExponentialFactor = 2.0

    [<Literal>]
    let JitterFactor = 0.5

    let backofJitter (attempt: int) (prev: byref<float>) (opts: RetryStrategyOptions) =

        // The original author/credit for this jitter formula is @george-polevoy .
        // Jitter formula used with permission as described at https://github.com/App-vNext/Polly/issues/530#issuecomment-526555979
        // Minor adaptations (pFactor = 4.0 and rpScalingFactor = 1 / 1.4d) by @reisenberger, to scale the formula output for easier parameterization to users.

        // A factor used within the formula to help smooth the first calculated delay.
        let pfactor = 4.0

        // A factor used to scale the median values of the retry times generated by the formula to be _near_ whole seconds, to aid Polly user comprehension.
        // This factor allows the median values to fall approximately at 1, 2, 4 etc seconds, instead of 1.4, 2.8, 5.6, 11.2.
        let rpScalingFactor = 1. / 1.4


        // Upper-bound to prevent overflow beyond TimeSpan.MaxValue. Potential truncation during conversion from double to long
        // (as described at https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions)
        // is avoided by the arbitrary subtraction of 1000. Validated by unit-test Backoff_should_not_overflow_to_give_negative_timespan.
        let maxTimeSpanDouble = (float) TimeSpan.MaxValue.Ticks - 1000.

        let targetTicksFirstDelay = float opts.Delay.Ticks

        let exponent = float attempt + opts.Randomizer.Invoke()

        let next = ExponentialFactor ** exponent * Math.Tanh(Math.Sqrt(pfactor * exponent))

        let formulaIntrinsicValue = next - prev
        prev <- next

        let m =
            Math.Min(formulaIntrinsicValue * rpScalingFactor * targetTicksFirstDelay, maxTimeSpanDouble)

        TimeSpan.FromTicks(int64 m)

    let applyJitter (delay: TimeSpan) (delayer: RetryStrategyOptions) =
        let offset = delay.TotalMilliseconds * JitterFactor / 2.

        let randomDelay =
            delay.TotalMilliseconds * JitterFactor * (delayer.Randomizer.Invoke()) - offset

        let newDelay = delay.TotalMilliseconds + randomDelay
        TimeSpan.FromMilliseconds(newDelay)

    let getRetryDelay (attempt: int) (prev: byref<float>) (opts: RetryStrategyOptions) =
        try
            let delay =
                if (opts.Delay = TimeSpan.Zero) then
                    TimeSpan.Zero
                else
                    match opts.BackoffType with
                    | DelayBackoffType.Constant when opts.UseJitter -> applyJitter opts.Delay opts
                    | DelayBackoffType.Constant -> opts.Delay

                    | DelayBackoffType.Linear when opts.UseJitter -> applyJitter (float (attempt + 1) * opts.Delay) opts
                    | DelayBackoffType.Linear -> float (attempt + 1) * opts.Delay

                    | DelayBackoffType.Exponential when opts.UseJitter -> backofJitter attempt &prev opts
                    | DelayBackoffType.Exponential -> ExponentialFactor ** (float attempt) * opts.Delay
                    | t ->
                        Throwhelpers.argumentOutOfRange t
                        TimeSpan.Zero

            if opts.MaxDelay ?<= delay then
                opts.MaxDelay.Value
            else
                delay
        with :? OverflowException ->
            if opts.MaxDelay.HasValue then
                opts.MaxDelay.Value
            else
                TimeSpan.MaxValue

    let untilCancellation (ct: CancellationToken) (e: Effect<'r, unit, 'e>) =
        let d = RetryStrategy(ct)

        eff {

            while not ct.IsCancellationRequested do
                try
                    do! Effect.forever (d.Delay(e))
                with
                | :? TaskCanceledException -> return ()
                | _ ->
                    //do! Logger
                    do! Task.Delay(1000, cancellationToken = ct)
        }
        |> Effect.changeError (fun _ -> Unchecked.defaultof<Nothing>)
